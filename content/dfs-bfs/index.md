---
emoji: 🧼
title: DFS & BFS | Depth-First Search & Breadth-First Search
date: '2021-11-17 23:00:00'
author: Yoonmin Cho
tags:
categories: data-structures
---

# 소개

// 그래프가 아니라 !! 트리 !! 였다.
그래프를 탐색하는 방법에는 크게 두 가지가 있다. 바로 DFS(깊이 우선 탐색)과 BFS(너비 우선 탐색)이다.
본격적으로 DFS와 BFS에 대해 알아보기 전에 **그래프** 란 무엇일까?

여기서 **그래프**란, 노드(정점)과 그 정점을 연결하는 edge(간선)으로 이루어진 자료구조의 일종을 말한다.
따라서 그래프를 탐색한다는 것은 하나의 정점으로부터 시작하여 차례대로 모든 정점들을 한 번씩 방문하는 것을 의미한다.

# DFS: Depth-First Search

> 최대한 깊이 내려간 뒤, 더이상 갈 곳이 없을 경우 옆으로 이동한다.

그림을 보면 대략적인 개념을 이해하기가 쉽다.

![dfs.gif](dfs.gif)

루트 노드 혹은 다른 임의의 노드에서 시작해서 다음 브랜치로 넘어가기 전에 해당 브랜치(분기)를 완벽하게 탐색하는 방식을 말한다.

1. 모든 노드를 방문하고자 하는 경우에 이 방법을 선택한다.
2. DFS가 BFS 보다 조금 더 간단하다.
3. 검색 속도 자체는 BFS에 비해 느리다.

# BFS: Breadth-First Search

> 최대한 넓게 이동한 다음, 더이상 갈 수 없을 때 아래로 이동한다.

그림을 보면 대략적인 개념을 이해하기 쉽다.

![bfs.gif](bfs.gif)

루트 노드 혹은 다른 임의의 노드에서 시작해서 인접한 노드를 먼저 탐색하는 방법으로, 시작 노드로부터 가까운 노드를 먼저 방문하고, 멀리 떨어져있는 노드를 나중에 방문하는 순회 방법이다.

주로 두 노드 사이의 **최단 경로**를 찾고 싶을 때 이 방법을 선택한다.

ex. 지구 상에 존재하는 모든 친구 관계를 그래프로 표현한 후 Sam과 Eddie 사이에 존재하는 경로를 찾는 경우

- DFS의 경우: 모든 친구 관계를 다 살펴봐야 할지도 모름
- BFS의 경우 : Sam과 가까운 관계부터 탐색

# DFS와 BFS 비교

![difference.gif](difference.gif)

|      | DFS                                                             | BFS                                       |
| ---- | --------------------------------------------------------------- | ----------------------------------------- |
| 탐색 | 현재 노드에서 엣지를 통해 들어갈 수 있는 노드까지 파고들며 탐색 | 현재 정점을 기준으로 가까운 노드부터 탐색 |
| 구현 | 스택 또는 재귀함수로 구현                                       | 큐를 이용하여 구현                        |

=======================================================================================================

# 선행 개념, 필요성

## 트리 개념 -1 | 트리 Tree

- 트리는 계층이 존재한다.
- 배열, 스택, 큐 등 선형적인 자료구조와 달리, 트리는 각 노드의 관계(부모-자식 관계)를 통해 "깊이"를 표현한다.
- 트리는 어떻게 그 깊이를 표현할까?
- 노드란, 트리를 구성하는 가장 기본 단위이다. 부모-자식은 각각 "노드"라고 불린다.
- 노드는 두 가지 정보를 담고 있다. 1) 다른 노드와의 차별점을 두는 데이터 2) 자식들과의 관계를 담고 있는 정보

## 트리 개념 -2 | 메모리 구조 안에서는 트리가 어떻게 동작할까?

- 부모는 자식 노드들의 "메모리 주소"를 갖고 있다.
- 부모 노드 안에서(그러니까 하나의 노드 안에서) 부모 노드와 자식 노드의 데이터가 / 값이 / 같이 저장되는건 아니다. 그저 부모 노드는 자식 노드에 언제든 접근할 수 있도록 자식 노드의 "메모리 주소" 값을 갖고 있을 뿐이다.

## 트리 구현

- Q. "트리" 구현의 핵심은 부모 노드에 자식과의 관계를, "부모 노드에 자식 노드의 메모리 주소를 어떻게 저장할 것인가" 에 대한 질문에서 시작된다.
- A. "배열" 을 이용하면 된다.
- 배열에 자식 노드들의 주소를 담으면 된다. 자식 노드를 생성하고 배열에 담으면, 자바스크립트는 알아서 주소를 맵핑해준다. 자식을 삭제하기 위해서는 배열에서 해당하는 원소만 제거해주면 해당하는 자식 노드의 정보(주소)가 사라진다.

# BFS: Breadth First Search

## 들어가기 전

- 트리를 탐색(순회)하는 방법 중에 하나가 바로 BFS 너비우선탐색이다.
- "트리를 탐색하다" 는 최상단 계층에 있는 노드부터 시작해서 "층을 따라", "계층을 따라" 가장 아래에 있는 노드까지 살펴보는 행위를 말한다.
- 근데 BFS와 DFS를 구분하는 것은 이 "계층" 이라는 것을 Breadth로 볼 것인가 아니면 Depth로 볼 것인가에 있다.
- "계층 = 너비"로 본다면 BFS이고, "계층 = 깊이"로 본다면 DFS이다.

## 개념

- 탐색에 있어서 우선 순위가 "계층 = 너비" 라는 것이 핵심이다.

## 구현

- "계층 = 너비"로 보니까 Queue를 이용해 구현해보자.

```js
class Tree {
  constructor() {
    this.root = null;
  }

  BFS(fn) {
    if (this.root === null) return;

    const unvisitedQueue = [this.root];
    while (unvisitedQueue.length !== 0) {
      const current = unvisitedQueue.shift(); //dequeue
      unvisitedQueue.push(...current.children);
      fn(current);
    }
  }
}
```

# DFS: Depth First Search

## 들어가기 전

- DFS와 BFS의 차이는 결국 방문해야 할 우선순위의 차이인 것이다.
- BFS 너비우선탐색은 "너비"가 우선이 되었지만, DFS 깊이우선탐색은 "깊이"가 우선이 된다.
- 방문해야할 우선선위가 부모로부터 자식이라면 DFS이고, 우선순위가 부모로부터 그 옆의 부모 노드라면 BFS이다.

## 개념

## 구현

-

```toc

```
