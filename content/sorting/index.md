---
emoji: 📈
title: 정렬 Sorting
date: '2021-11-15 23:00:00'
author: Yoonmin Cho
tags:
categories: algorithms
---

## **👋 개요**

정렬Sorting이란, 데이터를 특정 기준에 따라 순서대로 내열하는 것을 말한다. 프로그램에서 데이터를 가공할 때 오름차순이나 내림차순 등 어떤 식으로든 정렬해서 사용하는 경우가 많기 때문에 정렬 알고리즘은 프로그램을 작성할 때 가장 많이 사용되는 알고리즘 중 하나이다.

정렬 알고리즘은 다양한 상황에 매우 유용하게 사용된다. 각종 데이터 목록을 정리하고 싶을 때, 분포도의 중위값을 알아내고 싶을 때, 데이터에서 중복값을 잡아내고 싶을 때 등이다. 또한 정렬 알고리즘은 이진 탐색Binary Search의 전처리 과정이기도 하니 알고 넘어가도록 하자.
정렬 알고리즘의 종류는 굉장히 다양한데, 오늘은 이 중에서 가장 많이 사용되는 선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬에 대해 살펴보려고 한다. 더불어 자바스크립트에서 제공하는 기본 정렬 라이브러리를 적용하여 좀 더 효과적인 정렬 수행 방법도 다루려고 한다.

이제 본격적으로 문제 상황에 대해 생각해보자. 여기 숫자가 하나씩 적힌 카드가 10장이 있다.<br/>
이제 이 카드를 오름차순으로 정렬해보자.

![sort-1.jpeg](sort-1.jpeg)

어떻게 이 데이터(카드)를 정렬할 수 있을까? 보통은 카드를 빠르게 훑고 숫자가 0부터 9까지로 구성된 걸 눈치챈 다음 카드를 0부터 9까지 순차적으로 나열할 것이다. 이러한 과정 속에서 우리의 노는 우리도 모르게 데이터의 규칙성을 파악한다. 하지만 우리에게 쉽다고 컴퓨터에도 쉬운 일은 아니다. 컴퓨터는 인간과 다르게 데이터의 규칙성을 직관적으로 알 수 없으며, 어떻게 정렬을 수행할지에 대한 과정을 소스 코드로 작성하여 구체적으로 명시해야 한다.

이 포스팅에서는 위의 카드 예제를 기준으로 정렬 알고리즘을 살펴볼 것이다. 또한 예제는 모두 오름차순 정렬을 수행한다고 가정한다. 내림차순 정렬은 오름차순 정렬을 수행하는 알고리즘에서 크기 비교를 반대로 수행하면 된다. 또한 자바스크립트에서는 특정한 리스트의 원소를 뒤집는 메서드를 제공한다. 따라서 내림차순 정렬은 오름차순 정렬을 수행한 뒤에 그 결과를 Revser하여 내림차순 배열을 만들 수 있다.

## 🔗 **선택 정렬 Selection Sort**

요약 : 가장 작은 것을 선택해서 앞으로 보내는 과정을 반복해서 수행하다보면, 전체 데이터의 정렬이 이루어진다.

데이터가 무작위로 여러개 있을 때, 이 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복하면 어떨까? 이 방법은 가장 원시적인 방법으로 매번 "가장 작은 것을 선택" 한다는 의미에서 선택 정렬 알고리즘이라고 한다.

### 📍 동작 과정

**step 1.**
<br/>
배열에서 최솟값에 해당하는 요소의 index를 찾는다.(이하 minIndex)

**step 2.**
<br/>
minIndex의 값과 배열의 가장 첫 index의 값을 swap한다.

**step 3.**
<br/>
정렬된 부분을 제외한 나머지 배열에 대해 위의 단계를 반복한다.
나머지 배열에 하나의 요소가 남을 때까지 진행한다. 마지막 하나 남은 요소는 위 과정을 진행하지 않아도 이미 정렬이 되어있다.

### 📍 소스 코드

```js
function selectionSort(array) {
  for (let i = 0; i < array.length - 1; i++) {
    let minIndex = i;
    for (let j = i + 1; j < array.length; j++) {
      if (array[minIndex] > array[j]) {
        minIndex = j;
      }
    }
    if (minIndex !== i) {
      const temp = array[i];
      array[i] = array[minIndex];
      array[minIndex] = temp;
    }
  }
  return array;
}

selectionSort([7, 5, 9, 0, 3, 1, 6, 2, 4, 8]);
```

### 📍 시간 복잡도

선택 정렬은 O(N^2)의 시간 복잡도를 갖는다.

반복문이 얼마나 중첩되었는지를 기준으로 간단히 시간 복잡도를 판단할 수 있다.
<br/>
선택 정렬은 최솟값의 인덱스인 minIndex를 설정해주는 외부 반복문을 (N-1)번 실행하고, 이를 순회하면서 내부 반복문을 (N-1, N-2, ..., 1)번 실행하게 된다. 직관적으로 이해하자면, 코드 상으로 반복문이 이중으로 사용되었기 때문이라고 볼 수 있다.

### 📍 특징

매우 비효율적이다. 다만, 특정한 배열에서 가장 작은 데이터를 찾는 상황이 꽤나 빈번하므로 선택 정렬 소스 코드에 익숙해질 필요가 있다.

## 🔗 **삽입 정렬 Insertion Sort**

요약 : 데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입한다.

삽입 정렬은 동작 원리를 직관적으로 이해하기 쉬운 알고리즘에 속한다. 물론 삽입 정렬은 선택 정렬에 비해 구현 난이도가 높은 편이지만, 선택 정령에 비해 실행 시간 측면에서 더 효율적인 알고리즘으로 잘 알려져 있다.
특히 삽입 정렬은 필요할 때만 위치를 바꾸므로 "데이터가 거의 정렬되어 있을 때" 훨씬 효율적이다. 선택 정렬은 현재 데이터의 상태와 상관없이 무조건 모든 원소를 비교하고 위치를 바꾸는 반면, 삽입 정렬은 그렇지 않다.
삽입 정렬은 특정한 데이터를 적절한 위치에 "삽입" 한다는 의미에서 삽입 정렬이라고 부른다. 더불어 삽입 정렬은 특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다. 정렬되어 있는 데이터 리스트에서 적절한 위치를 찾은 뒤에, 그 위치에 삽입된다는 점이 특징이다.

특정한 데이터의 왼쪽에 있는 데이터들은 이미 정렬이 된 상태이므로 자기보다 작은 데이터를 만났다면 더 이상 데이터를 살펴볼 필요없이 그 자리에 삽입되면 되는 것이다.

### 📍 소스 코드

```js
function insertionSort(array) {
  for (let i = 1; i < array.length; i++) {
    let current = array[i];
    let left = i - 1;
    while (left >= 0 && array[left] > current) {
      array[left + 1] = array[left];
      left--;
    }
    array[left + 1] = current;
  }
  return array;
}
insertionSort([7, 5, 9, 0, 3, 1, 6, 2, 4, 8]);
```

### 📍 시간 복잡도

## 🔗 **퀵 정렬 Quick Sort**

요약 : 기준 데이터를 설정하고, 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾼다.

퀵 정렬은 가장 많이 사용되는 정렬 알고리즘이다. 이 포스팅에서는 다루지 않지만 퀵정렬과 비교할 만큼 빠른 알고리즘으로 "합병 정렬Merge Sort" 알고리즘이 있다. 이 두 가지 알고리즘은 대부분의 프로그래밍 언어에서 제공하는 정렬 라이브러리의 근간이 되는 알고리즘이기도 하다. 그렇다면 퀵 정렬은 도대체 어떻게 동작하길래 이름부터 "QUICK" 알고리즘인지 알아보자.

퀵 정렬은 기준을 설정한 다음, 큰 수와 작은 수를 교환한 후 배열을 반으로 나누는 방식으로 동작한다. 이해하기까지 시간이 걸리겠지만 원리를 이해하면, 합병 정렬Merge Sort, 힙 정렬Heap Sort 등 다른 고급 정렬 기법에 비해 쉽게 소스 코드를 작성할 수 있다.

### 예시

### 📍 소스 코드

### 📍 시간 복잡도

## 🔗 **계수 정렬 Count Sort**

요약 : 데이터의 크기가 제한되어 있을 때에 한해서 데이터의 개수가 매우 많더라도 빠르게 동작한다.

계수 정렬 알고리즘은 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘이다. 모든 데이터가 양의 정수인 상황을 가정해보자. 데이터의 개수가 N, 데이터 중 최댓값이 K일때, 계수 정렬은 최악의 경우에도 수행시간 O(N+K)를 보장한다. 계수 정렬은 이처럼 매우 빠르게 동작할 뿐만 아니라 원리 또한 매우 간단하다. 다만, 계수 정렬은 "데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때"만 사용할 수 있다.

예를 들어 데이터의 값이 무한한 범위를 가질 수 있는 실수형 데이터가 주어지는 경우, 계수 정렬은 사용하기 어렵다. 일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용할 수 있다. 예를 들어 0 이상 100 이하인 성적 데이터를 정렬할 때 계수 정렬이 효과적이다. 다만, 가장 큰 데이터와 가장 작은 데이터의 차이가 너무 크다면 계수 정렬은 사용할 수 없다. 계수 정렬이 이러한 특징을 가지는 이유는, 계수 정렬을 이용할 때는 "모든 범위를 담을 수 있는 크기의 배열을 선언" 해야하기 때문이다. 예를 들어 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000이라면 총 1,000,001개의 데이터가 들어갈 수 있는 배열을 initialize 해야한다. 여기에서 1개를 더해주는 이유는 0부터 1,000,000까지는 총 1,000,001개의 수가 존재하기 때문이다.

계수 정렬은 위에서 다룬 정렬 알고리즘처럼 직접 데이터의 값을 비교한뒤에 위치를 변경하며 정렬하는 방식(비교 기반의 정렬 알고리즘)이 아니다. \*비교 정렬 알고리즘 : 선택 정렬, 삽입 정렬, 퀵 정렬처럼 데이터를 비교하며 위치를 변경하는 정렬 방법

계수 정렬은 일반적으로 별도의 리스트를 선언하고 그 안에 정렬에 대한 정보를 담는다는 특징이 있다. 구체적인 예시를 통해 계수 정렬에 대해서 이해해보자. 계수 정렬은 데이터의 크기가 제한되어 있다면, 데이터의 개수가 아무리 많더라도 빠르게 동작한다. 따라서 예시 또한 많은 데이터가 존재하는 경우를 살펴보자.

### 예시

### 📍 소스 코드

### 📍 시간 복잡도

## 🔗 **자바스크립트의 정렬 라이브러리**

앞서 보았던 것처럼 정렬 알고리즘을 직접 작성하게 되는 경우도 있지만, 미리 만들어진 라이브러리를 이용하는 것이 효과적인 경우가 더 많다.
자바스크립트는 기본 정렬 라이브러리인 sort() 함수를 제공한다.
sort() 는 퀵 정렬과 동작 방식이 비슷한 병합 정렬을 기반으로 만들어졌는데, 병합 정렬은 일반적으로 퀵 정렬보다 느리지만 최악의 경우에도 시간 복잡도 O(NlogN)을 보장한다는 특징이 있다. 이러한 sort() 함수는 딕셔너리 자료형 등을 입력받아서 정렬된 결과를 출력한다. 집합 자료형이나 딕셔너리 자료형을 입력받아도 반환되는 결과는 리스트 자료형이다.

## 👋 **마무리**

지금까지 다양한 정렬 알고리즘에 대해 알아보았다.

```toc

```
